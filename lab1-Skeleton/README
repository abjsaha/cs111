CS 111 Spring 2015
Lab 1a - Shell Command Reader

Michelle Doelling
604339240
Discussion 1C

Abhijoy Saha
004252758
Discussion 1A

To our knowledge, our program does not have any limitations that would cause it to behave incorrectly according to the spec requirements. Our implementation is separated into three major components. The first is reading in the input, parsing it, and deciding what to store in a temporary array that will be either a complete simple command or complete operator. This function
called handlechar then passes this temporary array to another function called growTree which is responsible for taking in the 
command or operator and deciding what to do with it using two separate stacks, an operator stack and a command stack, which are
both implemented using linked lists. These stacks are used to combine commands into a command tree. Lastly, this command tree 
is passed to addToCommandStream, which creates a linked list of root command nodes, each of which represent an entire command 
tree. Finally, we send this stream to read command stream. 




--------------------------------------------------------------
1B

README

Discussion Notes 4/17/2015
Lab 1b - due next Thursday

Goal: execute commands

Simple Commands: 
	- command->u.word
	- ex: "echo abc" --> word[0] = echo, word[1] = abc
	- execute simple commands using system call execvp
		- #include <unistd.h>
		- int execvp (const char *file, char *const argv)
		- first argument = word[0], second argument = word
		- char *arg[] = {"ls", "-l", "/etc/resolv.conf", \0}
		- execvp(arg[0],arg)
	- first call of execvp will exit the main process upon successful execution
	- next call of execvp on the same word will not be executed
	- this is because execvp calls fork()
	- example: cat a.txt (where a.txt does not exist) 
		- will not return to main process because cat can still be executed
	- example: cat2 a.txt
		- this fails to execute because it does not recognize cat2 as a command
		- so it will return to the main process and continue executing code following 
		  the system call to execvp().

echo a ; echo b requires more than one process to execute this command
int p = fork();
if (p == 0) {
	char* command[] = {"echo", "a", 0}
	execvp(command[0], command);
}
else {
	char* command[] = {"echo", "b", 0};
	execvp(command[0], command);
}
//no synchonrization in this case, so we don't know if child or parent process finishes first

we are interested in synchonrization for and, or, and pipe commands
example: echo a || echo b
	- if echo a is true, we will not execute echo b
	- we have to make sure echo a is finished first, then check exit status
	- for exit status, 0 = successful
	- echo $? obtains the exit status 
	- echo b needs to wait for echo a to be executed, and must also obtain exit status
		- if exit status = 0, then we don't execute echo b

int p = fork();
if (p == 0) {
	.. same as ex above}
else {
	int status;
	waitpid(p, &status, 0)    //#include <sys/wait.h>
	if (exitstatus == 1) {	  //first part not successful, so we execute next part
		char *command[] = {"echo", "b", 0};
		execvp(command[0],command);
}

- third argument of waitpid is the status of waiting for the child process to finish
- blocking implementation (wait until child finishes)
- int status is not just the exit status
- exit status is only the least sig 8 bits of the 32-bit status
- to extract least sig 8 bits: int exitstatus = WEXITSTATUS(status)
	-exitstatus = 0 if successfully executes

3 cases for exit status:
- command fails (ex: echo2, command does not exist)
	- returns 127, will return to process that called execvp
- command executes unsuccessfully (ex: cat a.txt, cat is a command but a.txt dne)
	- returns non-0, does not return to process that called execvp
- command executes successfully (ex: echo a)
	- returns 0, does not return to process that called execvp

in lab 1b, assume every command is valid so commands should never fail
but they could execute unsuccessfully

Redirections > <
recall: stdin = 0, stdout = 1, stderr = 2
echo abc > a.txt
- finds available file descriptor and assigns it to name a.txt
- execvp always goes to stdout
- we want a.txt and stdout to have the same file descriptor (generate an alias)

int dup2 (int fd1, int fd2) { 	//#include <unistd.h>
	close (fd2);
	dup(fd1);
}

in example: echo abc > a.txt
fd1 = open(a.txt)
fd2 = stdout
//generates file descriptor so that anything that writes to stdout writes to a.txt

#include <unistd.h> //for dup
#include <fcntl.h> //for open

int main(){
	char *a[] = {"echo", "abc", 0};
	int fd = open ("a.txt", O_CREAT | O_TRUNC | O_WRONLY, 0644);
		//o_creat means if file already exists, destroy and recreate
		//trunc = fill will all 0 bytes
		//wronly = write
		//0644 = permission of file
	if (fd<0) return;
	dup2(fd,1);
		//this is for stdout
		//for stdin, use dup2(fd,0)
	execvp(a[0], a);
}

backup stdout: int stdout_backup = dup(1)
then we can do this: dup2(fd,1) because we already have backup of stdout
eventually restore stdout: dup2(stdout_backup,1)

wait pid can specify WNOHANG instead of 0 returns immediately regardless of whether or not
child process finished, prevents parent waiting for child in an infinite loop

////////////////////////////////////
Most difficult command: PIPE_COMMAND
////////////////////////////////////
example: cat foo.txt | sort
- cat foo.txt writes to stdout
- sort usually reads from stdin
- but in this case, the | indicates that cat foo.txt should write to the place where 
  sort reads from (unidirectional)

file descriptor used for input: dup2(fd1,1)
file descriptor used for output: dup2(fd2,0)
pipe(int fd[2]) finds two available file descriptors and stores it in an array
	-#include <unistd.h>
	-fd[0] used for reading
	-fd[1] used for writing
int fd[2]
pipe(fd)
first end of pipe uses fd[1] and second end uses fd[2]
basically pipe() command allocates two file descriptors
cat foo.txt (fd[1])-------> (fd[2])------> sort
in this case we need to create two child processes, one for each side of the | operator

int main(){
	int fd[2];
	pipe(fd);
	int firstPid = fork();
	if (firstPid == 0){
		//execute command on the right
		close(fd[1]);  		 //close unused write end
		dup2(fd[0], \0);
		char *a[] = {"sort",0};
		execvp(a[0],a);
	}
	else{
		int secondPid = fork();
		if (secondPid == 0) {
			//execute command on the left
			close(fd[0]);		//close unused read end
			dup2(fd[1],1);
			char *a[] = {"cat", "food.txt", 0};
			execvp(a[0],a);
		}
		else {         //parent
			close(fd[0]);          //for synchronization purposes
			close(fd[1]);
			int status;
			int returnedPid = waitpid(-1, &status, 0);   //-1 because doesnt matter   
			if (returnedPid == secondPid){
				waitpid(firstPid, &status, 0);
				//set exit status of second
			}
			if (returnedPid == firstPid){
				wantpid(secondPid, &status, 0);
				//set exit status of first
			}
		}
	}
}

choosing which fd to close determines direction of the pipe and which nodes (parent, 
child1 or child2) the pipe is active between