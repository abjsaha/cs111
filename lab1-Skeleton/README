This is a skeleton for CS 111 Lab 1.

Replace this README file with notes on your implementation.
Mentions any special features or limitations.

Michelle Doelling
604339240
Discussion 1C

Partner: Abhijoy Saha

Week 1: Discussion 1A
Notes about Lab 1A

read-command.c
1. command_stream_t make_command_stream
	- command_stream is a collection of command trees
	- ex: a||b;c&&d|e is a collection of commands, or a tree
	- command trees are separated by two or more new lines
	- single new line can be interpreted as a sequence command (;)
		- a \n b is the same as a;b 
	- multiple new lines distinguishes separate command trees
	- for a command such as &&, it must have a left and right operand so new lines are ignored
		- a&&b is the same as a&&\n\nb
2. command_t read_command_stream


command_internals.h
struct command h

we need to read the script and store the commands into struct command
our job is to reduce a complicated command to a top level command
sorting it into a command tree with a single root
example:	ls | grep s
			- store ls in command[0] as a SIMPLE_COMMAND
			- store grep s in command[1] as a SIMPLE_COMMAND

			struct command *ls_command = (struct command*) malloc(...)
			ls_command->type = SIMPLE_COMMAND
			we can ignore ls_command->status (only matters for 1b and 1c) or set to -1 (default value)
			char *input and char *output depend on < and > 
			in this example, set these to null
			ls is a command, not an operator so we dont need to use struct command *command[2]
			char **word we need to store "ls" followed by nullbyte
				->u.word[0] = "ls"
				->u.word[1] = \0;
					as another example: ls -l a.txt
						word[0] = "ls"
						word[1] = -l
						word[2] = a.txt
						word[3] = \0
			subshell_command can be ignored for ls in this example because it is not a subshell command
			next do the same for grep:
				grep_command where word[0] = grep, word[1] = s, word[2] = \0
			next define pipe_command
				pipe_command->u.command[0] = ls_command
				pipe_command->u.command[1] = grep_command
				don't store char **word because it is an operator, not a command
			in this example of a command tree, the | command is the root of the tree
			command[0] is the left of the tree and command[1] is the right of the tree
			this allows us to recursivley visit all nodes of the tree

precendence of operators:
lowest:  sequence commands: ; or \n
		 and or: && ||
highest: pipe: |

next example: a;b&&c|d;(e)<f
	first identify that | is the highest precedence
		define SIMPLE_COMMAND for c
		define SIMPLE_COMMAND for d
		define PIPE_COMMAND for | <-- this is the root of the tree
	next identify that && is the highest precedence for the portion to the left of |
		define AND_COMMAND where command[0] is b and command[1] store pipe command defined above (c|d)
	next is the sequence command a;[b&&c|d]
		define SEQUENCE_COMMAND where command[0] is a and command[1] is the AND_COMMAND defined above
	next is the sequence command to the right of the pipeline
		define SEQUENCE_COMMAND where command[0] is the first SEQUENCE_COMMAND defined and the right side command[1] is covered by (e)<f, explained below
	focus on (e)<f
		similar: e<f: this is a simple command with input = f, word[0] = e and word[1] = \0
		(e) is a subshell command:
			struct command *subshell = subshell->type=SUBSHELL_COMMAND, input = f, word is nothing, 
			->u.subshell_command = simplecommand_e
		so for another example: (a&&b||c) first define command a&&b||c and set that as the struct command *subshell_command for the SUBSHELL_COMMAND
		back to (e)<f, f is the input to the subshell (e)


automate the process of constructing a tree
infix --> postfix
implement two stacks: operator stack and command stack
parse script from left to right
- if simple command, push onto command stack
- if (, push onto operator stack
- if operator and operator stack is empty, push the operator onto the operator stack
- if operator and operator stack is not empty, pop all operators with greater/equal precedence off of the operator stack
	* for each operator, pop two commands off command stack
	  combine into new command and push it on command stack
	* stop when reach an operator with lower precedence or a (
	* push new operator onto operator stack
- if ), pop operators off until matching (
	* create subshell command by popping off top command on command stack
- if < or >, simply pop top command, set input or output field to character after < or >, push back on

for example: a&&b||c
1. push a onto command stack
2. push && onto operator stack
3. push b onto command stack
4. pop && from operator stack
5. create new command by popping a and b and combining with &&
6. push this new command on command stack
7. push || onto operator stack
8. push c onto command stack
9. combine (a&&b) command with || operator and c command

for example: a;b&&c|d;(e)<f
1. push a on command stack
2. push ; onto operator stack
3. push b on command stack
4. compare && and ; presedence
5. push && onto operator stack because ; has lower presedence
6. push c onto command stack
7. push  | on operator stack because nothing has equal/higher presedence
8. push d onto command stack
9. pop |, combine with top two commands: d and c, push c|d onto command stack
10. pop &&, combine with two top commands: c|d and b, push b&&c|d onto command stack
11. pop ;, combine with two top commands: b&&c|d and a, push a;b&&c|d onto command stack
12. push ; onto operator stack (this is the second ;)
13. push ( onto operator stack
14. push e onto command stack
15. pop top command from command stack, create subshell command of e, push (e) onto command stack
16. pop top command, set input field to f so that subshell's input field (e) is f, push it back so stack remains the same


MAKE COMMAND STREAM
up until this point, we parse and store into a struct command
command.h file shows struct command *command_t and struct command_stream *command_stream_t
struct command is defined in command_internals.h
we have no current definition of struct command_stream
each root node is of type struct command
command stream is a collection of struct commands (linked list)

each commandNode is a tree
struct commandNode {
	struct command *command; //stores root of command tree
	struct cmomandNode *next;
}

typedef struct command_stream{
	struct commandNode *head;
	struct commandNode *tail;
} command_stream;


a&&b \n
\n
c

create tree &&                and another tree    c
			/\                         this tree is c_command (only one node)
		   a  b
this tree is and_command
commandNode->command=and_command
commandNode2->command=c_command
stream is a linked list connecting these two commandNodes
lowest presedence operator tends to be at the top of the tree


READ COMMAND STREAM
look in main.c to see what it returns
it returns cursor pointer to next node in the stream

read...(command_stream_t s) {
	if s->cursor==NULL
		return NULL
	struct commandNode *temp = s->cursor
	s->cursor = s->cursor->next
	return temp;
}